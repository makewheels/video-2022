<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>上传视频</title>

    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="https://code.bdstatic.com/npm/@baiducloud/sdk@1.0.0-rc.32/dist/baidubce-sdk.bundle.min.js"></script>
    <script src="https://lib.baomitu.com/async/3.2.3/async.min.js"></script>
</head>

<body>
<script>
    //看有没有token，如果没有跳转登录页
    if (localStorage.getItem("token") == null) {
        window.location.href = "//" + document.domain + ":5021/user-micro-service-2022/login.html" +
            "?target=" + window.location.href
    }
</script>

<input type="file" id="input_file"/>
<br>

<span>Title:</span>
<input id="input_title" type="text" maxlength="100"/>
<br>

<span>Description:</span>
<input id="input_description" type="text" maxlength="1000"/>
<br>

<button id="btn_update" type="button">修改</button>
<br>

<span id="shortUrl"></span>
<br>

<span id="watchUrl"></span>
<br>

<b>
    <span id="text_progress" style="color: blue;margin-left: 20px;font-size: 30px"></span>
</b>

<script>
    let input_file = document.getElementById("input_file");

    let input_title = document.getElementById("input_title");
    let input_description = document.getElementById("input_description");
    let btn_update = document.getElementById("btn_update");

    let shortUrl = document.getElementById("shortUrl");
    let watchUrl = document.getElementById("watchUrl");

    let text_progress = document.getElementById("text_progress");

    // 监听选中文件
    input_file.onchange = () => {
        const selectedFile = input_file.files[0];
        let originalFilename = selectedFile.name;
        let size = selectedFile.size;
        input_title.value = originalFilename.substring(0, originalFilename.indexOf("."));
        createVideo(originalFilename, size, "USER_UPLOAD");
    }

    let fileId;
    let videoId;
    let watchId;

    //创建视频
    function createVideo(originalFilename, size, type) {
        axios.post("/video/create", {
            originalFilename: originalFilename,
            size: size,
            type: type
        }, {
            headers: {"token": localStorage.token}
        }).then(function (res) {
            let data = res.data.data;
            fileId = data.fileId;
            videoId = data.videoId;
            watchId = data.watchId;

            shortUrl.innerText = data.shortUrl;
            watchUrl.innerText = data.watchUrl;
            beginUpload();
        });
    }

    //修改视频信息按钮
    btn_update.addEventListener("click", function () {
        if (videoId === undefined) {
            return;
        }
        axios.post("/video/updateInfo", {
            id: videoId,
            title: input_title.value,
            description: input_description.value
        }, {
            headers: {"token": localStorage.token}
        }).then(function (res) {
        });
    });

    //断点续传localStorage的key
    var generateLocalKey = function (blob, chunkSize, bucket, object) {
        return "baidu-bos-uploadId-" + [blob.size, chunkSize, bucket, object].join('&');
    };
    var getUploadId = function (key) {
        return localStorage.getItem(key);
    };
    var setUploadId = function (key, uploadId) {
        return localStorage.setItem(key, uploadId);
    };
    var removeUploadId = function (key) {
        return localStorage.removeItem(key);
    };

    var initiateMultipartUpload = function (file, chunkSize, bucket, object) {
        // 根据文件生成localStorage的key
        var key = generateLocalKey(file, chunkSize, bucket, object);
        // 获取对应的`uploadId`
        var uploadId = getUploadId(key);
        if (uploadId) {
            // `uploadId`存在，说明有未完成的分块上传。
            // 那么调用`listParts()`获取已上传分块信息。
            return bosClient.listParts(bucket, object, uploadId)
                .then(function (response) {
                    // response.body.parts里包含了已上传分块的信息
                    response.body.uploadId = uploadId;
                    return response;
                });
        } else {
            // `uploadId`不存在，那么用正常的流程初始化
            return bosClient.initiateMultipartUpload(bucket, object)
                .then(function (response) {
                    // response.body.uploadId为新生成的`uploadId`
                    response.body.parts = [];
                    // 为了下次能使用断点续传，我们需要把新生成的`uploadId`保存下来
                    //2022年4月9日13:33:28
                    //难点在于，我每次都相当于新建object key
                    //uploadId是跟key对应的，如果想断点续传，只js计算md5不够，必须后端拿到上一次的key
                    //这有点麻烦，先不做了
                    //其实就是后端存一个你上次上传的未完成的草稿，下次再开始上传的时候，先检查草稿
                    //最主要的是要下发object key
                    //uploadId也可以存在后端，所以其实前端不需要localStorage了

                    // setUploadId(key, response.body.uploadId);
                    return response;
                });
        }
    }

    function getEtag(partNumber, parts) {
        // 从已上传part列表中找出特定partNumber的part的eTag
        for (var i = 0, l = parts.length; i < l; i++) {
            if (parts[i].partNumber === partNumber) {
                return parts[i].eTag;
            }
        }
        return null;
    }

    function getTasks(file, uploadId, chunkSize, bucket, object, parts) {
        var leftSize = file.size;
        var offset = 0;
        var partNumber = 1;

        var tasks = [];

        while (leftSize > 0) {
            var partSize = Math.min(leftSize, chunkSize);
            var task = {
                file: file,
                uploadId: uploadId,
                bucket: bucket,
                object: object,
                partNumber: partNumber,
                partSize: partSize,
                start: offset,
                stop: offset + partSize - 1
            };

            // 如果在已上传完成的分块列表中找到这个分块的etag，那么记录下来
            var etag = getEtag(partNumber, parts);
            if (etag) {
                task.etag = etag;
            }
            tasks.push(task);
            leftSize -= partSize;
            offset += partSize;
            partNumber += 1;
        }
        return tasks;
    }

    function updateProgress(state) {
        let progress = state.loaded / state.total;
        progress = progress * 100;
        text_progress.innerText = (progress.toFixed(2) + " %");
    }

    // 在进行分块上传处理的时候，根据是否已带有etag字段来决定是否需要上传：
    function uploadPartFile(state, bosClient) {
        return function (task, callback) {
            if (task.etag) {
                // 如果有etag字段，则直接跳过上传
                callback(null, {
                    http_headers: {
                        etag: task.etag
                    },
                    body: {}
                });
                updateProgress(state);
            } else {
                // 否则进行上传
                var blob = task.file.slice(task.start, task.stop + 1);
                bosClient.uploadPartFromBlob(task.bucket, task.object, task.uploadId,
                    task.partNumber, task.partSize, blob)
                    .then(function (res) {
                        ++state.loaded;
                        callback(null, res);
                        updateProgress(state);
                    })
                    .catch(function (err) {
                        callback(err);
                    });
            }
        };
    }

    let chunkSize = 2 * 1024 * 1024; // 分块大小
    let uploadId;

    let bucket;
    let key;

    let bosClient;

    //获取上传凭证
    function getUploadCredentials() {
        axios.get("/file/getUploadCredentials?fileId=" + fileId, {
            headers: {"token": localStorage.token}
        }).then(function (res) {
            runUpload(res.data.data);
        });
    }

    //拿到凭证之后，真正开始上传
    function runUpload(uploadCredentials) {
        bucket = uploadCredentials.bucket;
        key = uploadCredentials.key;
        let bosConfig = {
            credentials: {
                ak: uploadCredentials.accessKeyId,
                sk: uploadCredentials.secretKey
            },
            sessionToken: uploadCredentials.sessionToken,
            endpoint: uploadCredentials.endpoint,
        };
        bosClient = new baidubce.sdk.BosClient(bosConfig);
        initiateMultipartUpload(input_file.files[0], chunkSize, bucket, key)
            .then(function (response) {
                uploadId = response.body.uploadId; // uploadId，可能是服务器刚刚生成的，也可能是从localStorage获取的
                var parts = response.body.parts || []; // 已上传的分块列表。如果是新上传，则为空数组
                var deferred = baidubce.sdk.Q.defer();
                var tasks = getTasks(input_file.files[0], uploadId, chunkSize, bucket, key, parts);
                var state = {
                    lengthComputable: true,
                    loaded: parts.length, // 已上传的分块数
                    total: tasks.length
                };
                // 如果已上传的分块数大于0，可以先修改一下文件上传进度
                bosClient.emit('progress', state);
                // 为了管理分块上传，使用了async（https://github.com/caolan/async）库来进行异步处理
                var THREADS = 3; // 同时上传的分块数量
                async.mapLimit(tasks, THREADS, uploadPartFile(state, bosClient), function (err, results) {
                    if (err) {
                        deferred.reject(err);
                    } else {
                        deferred.resolve(results);
                    }
                });
                return deferred.promise;
            })
            .then(function (allResponse) {
                var partList = [];
                allResponse.forEach(function (response, index) {
                    // 生成分块清单
                    partList.push({
                        partNumber: index + 1,
                        eTag: response.http_headers.etag
                    });
                });

                // 所有分块上传完成后，可以删除对应的`uploadId`了
                removeUploadId(key, uploadId);

                return bosClient.completeMultipartUpload(bucket, key, uploadId, partList); // 完成上传
            })
            .then(function (res) {
                // 上传完成
                onUploadFinish();
            })
            .catch(function (err) {
                // 上传失败，添加您的代码
                console.error(err);
            });
    }

    //我的开始上传文件
    function beginUpload() {
        getUploadCredentials();
    }


    //在上传完成时
    function onUploadFinish() {
        //通知文件上传完成
        axios.get("/file/uploadFinish?fileId=" + fileId, {
            headers: {"token": localStorage.token}
        }).then(function (res) {
            //通知视频 源文件上传完成
            axios.get("/video/originalFileUploadFinish?videoId=" + videoId, {
                headers: {"token": localStorage.token}
            }).then(function (res) {
                text_progress.innerText = "上传已完成";
            });
        });
    }
</script>

</body>
</html>